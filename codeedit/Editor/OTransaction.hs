{-# LANGUAGE TemplateHaskell, GeneralizedNewtypeDeriving #-}
module Editor.OTransaction
  ( OTransaction, runOTransaction
  , unWrapInner
  , WidgetT
  , readCursor, subCursor
  , Env(..)
  , atEnv, atEnvCursor
  , envAssignCursor, envAssignCursorPrefix
  , assignCursor, assignCursorPrefix
  , readTextStyle, transaction
  , atEnvTextStyle, setTextSizeColor
  , markVariablesAsUsed, usedVariables
  , getP
  , getName, NameSource(..)
  ) where

{- Outer transaction -}

import Control.Applicative (Applicative, liftA2)
import Control.Monad (liftM)
import Control.Monad.Trans.Class (lift)
import Control.Monad.Trans.RWS (RWST, runRWST)
import Data.Map (Map)
import Data.Store.Guid (Guid)
import Data.Store.Transaction (Transaction)
import Editor.Anchors (MkProperty)
import Editor.ITransaction (ITransaction)
import Graphics.UI.Bottle.Animation (AnimId)
import Graphics.UI.Bottle.Widget (Widget)
import qualified Control.Monad.Trans.RWS as RWS
import qualified Data.AtFieldTH as AtFieldTH
import qualified Data.Map as Map
import qualified Data.Store.Property as Property
import qualified Editor.Anchors as Anchors
import qualified Graphics.DrawingCombinators as Draw
import qualified Graphics.UI.Bottle.Widget as Widget
import qualified Graphics.UI.Bottle.Widgets.TextEdit as TextEdit
import qualified Graphics.UI.Bottle.Widgets.TextView as TextView

data Env = Env {
  envCursor :: Widget.Id,
  envTextStyle :: TextEdit.Style
  }
AtFieldTH.make ''Env

type WidgetT t m = Widget (ITransaction t m)

data NameGenState = NameGenState
  { ngUnusedNames :: [String]
  , ngUsedNames :: Map Guid String
  }

initialNameGenState :: NameGenState
initialNameGenState =
  NameGenState names Map.empty
  where
    alphabet = map (:[]) ['a'..'z']
    names = alphabet ++ liftA2 (++) names alphabet

newtype OTransaction t m a = OTransaction
  { unOTransaction :: RWST Env [Guid] NameGenState (Transaction t m) a
  }
  deriving (Functor, Applicative, Monad)
AtFieldTH.make ''OTransaction

transaction :: Monad m => Transaction t m a -> OTransaction t m a
transaction = OTransaction . lift

getP :: Monad m => MkProperty t m a -> OTransaction t m a
getP = transaction . liftM Property.value

runOTransaction
  :: Monad m
  => Widget.Id -> TextEdit.Style
  -> OTransaction t m a -> Transaction t m a
runOTransaction cursor style (OTransaction action) =
  liftM f $ runRWST action (Env cursor style) initialNameGenState
  where
    f (x, _, _) = x

generateNewName :: Monad m => Guid -> OTransaction t m String
generateNewName guid = do
  nameGen <- OTransaction RWS.get
  let (name : nextNames) = ngUnusedNames nameGen
  OTransaction $ RWS.put nameGen
    { ngUnusedNames = nextNames
    , ngUsedNames = Map.insert guid name $ ngUsedNames nameGen
    }
  return name

data NameSource = AutoGeneratedName | StoredName

getName :: Monad m => Guid -> OTransaction t m (NameSource, String)
getName guid = do
  storedName <- transaction . Anchors.getP $ Anchors.assocNameRef guid
  -- TODO: maybe use Maybe?
  if null storedName
    then
      liftM ((,) AutoGeneratedName) .
      maybe (generateNewName guid) return =<<
      (OTransaction . RWS.gets) (Map.lookup guid . ngUsedNames)
    else return (StoredName, storedName)

markVariablesAsUsed :: Monad m => [Guid] -> OTransaction t m ()
markVariablesAsUsed = OTransaction . RWS.tell

usedVariables
  :: Monad m
  => OTransaction t m a -> OTransaction t m (a, [Guid])
usedVariables = atOTransaction RWS.listen

unWrapInner
  :: Monad m
  => (Transaction t0 (Transaction t1 m) a -> Transaction t1 m a)
  -> OTransaction t0 (Transaction t1 m) a
  -> OTransaction t1 m a
unWrapInner unwrap act = do
  cursor <- readCursor
  style <- readTextStyle
  transaction . unwrap $ runOTransaction cursor style act

readCursor :: Monad m => OTransaction t m Widget.Id
readCursor = OTransaction $ RWS.asks envCursor

subCursor :: Monad m => Widget.Id -> OTransaction t m (Maybe AnimId)
subCursor folder = liftM (Widget.subId folder) readCursor

readTextStyle :: Monad m => OTransaction t m TextEdit.Style
readTextStyle = OTransaction $ RWS.asks envTextStyle

envAssignCursor
  :: Widget.Id -> Widget.Id -> Env -> Env
envAssignCursor src dest =
  atEnvCursor replace
  where
    replace cursor
      | cursor == src = dest
      | otherwise = cursor

envAssignCursorPrefix
  :: Widget.Id -> Widget.Id -> Env -> Env
envAssignCursorPrefix srcFolder dest =
  atEnvCursor replace
  where
    replace cursor =
      case Widget.subId srcFolder cursor of
      Nothing -> cursor
      Just _ -> dest

assignCursor :: Monad m => Widget.Id -> Widget.Id -> OTransaction t m a -> OTransaction t m a
assignCursor x y = atEnv $ envAssignCursor x y

assignCursorPrefix :: Monad m => Widget.Id -> Widget.Id -> OTransaction t m a -> OTransaction t m a
assignCursorPrefix x y = atEnv $ envAssignCursorPrefix x y

setTextSizeColor
  :: Int
  -> Draw.Color
  -> Env
  -> Env
setTextSizeColor textSize textColor =
  (atEnvTextStyle . TextEdit.atSTextViewStyle)
  ((TextView.atStyleFontSize . const) textSize .
   (TextView.atStyleColor . const) textColor)

atEnv :: Monad m => (Env -> Env) -> OTransaction t m a -> OTransaction t m a
atEnv = atOTransaction . RWS.local
