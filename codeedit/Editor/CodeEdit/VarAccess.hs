{-# LANGUAGE GeneralizedNewtypeDeriving, TemplateHaskell #-}
module Editor.CodeEdit.VarAccess
  ( VarAccess, run
  , AccessedVars
  , markVariablesAsUsed, usedVariables
  , otransaction, transaction, atEnv
  , assignCursor, assignCursorPrefix
  , getP
  , getName, NameSource(..)
  , WidgetT
  ) where

import Control.Applicative (Applicative, liftA2)
import Control.Monad (liftM)
import Control.Monad.Trans.Class (lift)
import Control.Monad.Trans.RWS (RWST, runRWST)
import Data.Map (Map)
import Data.Store.Guid (Guid)
import Data.Store.Transaction (Transaction)
import Editor.Anchors (ViewTag)
import Editor.ITransaction (ITransaction)
import Editor.OTransaction (OTransaction)
import Graphics.UI.Bottle.Widget (Widget)
import qualified Control.Lens as Lens
import qualified Control.Lens.TH as LensTH
import qualified Control.Monad.Trans.RWS as RWS
import qualified Data.Map as Map
import qualified Editor.Anchors as Anchors
import qualified Editor.OTransaction as OT
import qualified Graphics.UI.Bottle.Widget as Widget

type WidgetT m = Widget (ITransaction ViewTag m)

type AccessedVars = [Guid]

data NameGenState = NameGenState
  { ngUnusedNames :: [String]
  , ngUsedNames :: Map Guid String
  }

newtype VarAccess m a = VarAccess
  { _varAccess :: RWST () AccessedVars NameGenState (OTransaction ViewTag m) a }
  deriving (Functor, Applicative, Monad)
LensTH.makeLenses ''VarAccess

atEnv :: Monad m => (OT.Env -> OT.Env) -> VarAccess m a -> VarAccess m a
atEnv = Lens.over varAccess . RWS.mapRWST . OT.atEnv

run :: Monad m => VarAccess m a -> OTransaction ViewTag m a
run (VarAccess action) =
  liftM f $ runRWST action () initialNameGenState
  where
    f (x, _, _) = x

otransaction :: Monad m => OTransaction ViewTag m a -> VarAccess m a
otransaction = VarAccess . lift

transaction :: Monad m => Transaction ViewTag m a -> VarAccess m a
transaction = otransaction . OT.transaction

assignCursor :: Monad m => Widget.Id -> Widget.Id -> VarAccess m a -> VarAccess m a
assignCursor x y = atEnv $ OT.envAssignCursor x y

assignCursorPrefix :: Monad m => Widget.Id -> Widget.Id -> VarAccess m a -> VarAccess m a
assignCursorPrefix x y = atEnv $ OT.envAssignCursorPrefix x y

-- Used vars:

usedVariables
  :: Monad m
  => VarAccess m a -> VarAccess m (a, [Guid])
usedVariables = Lens.over varAccess RWS.listen

markVariablesAsUsed :: Monad m => AccessedVars -> VarAccess m ()
markVariablesAsUsed = VarAccess . RWS.tell

-- Auto-generating names

initialNameGenState :: NameGenState
initialNameGenState =
  NameGenState names Map.empty
  where
    alphabet = map (:[]) ['a'..'z']
    names = alphabet ++ liftA2 (++) names alphabet

generateNewName :: Monad m => Guid -> VarAccess m String
generateNewName guid = do
  nameGen <- VarAccess RWS.get
  let (name : nextNames) = ngUnusedNames nameGen
  VarAccess $ RWS.put nameGen
    { ngUnusedNames = nextNames
    , ngUsedNames = Map.insert guid name $ ngUsedNames nameGen
    }
  return name

data NameSource = AutoGeneratedName | StoredName

getName :: Monad m => Guid -> VarAccess m (NameSource, String)
getName guid = do
  storedName <- transaction . Anchors.getP $ Anchors.assocNameRef guid
  -- TODO: maybe use Maybe?
  if null storedName
    then
      liftM ((,) AutoGeneratedName) .
      maybe (generateNewName guid) return =<<
      (VarAccess . RWS.gets) (Map.lookup guid . ngUsedNames)
    else return (StoredName, storedName)

getP :: Monad m => Anchors.MkProperty ViewTag m a -> VarAccess m a
getP = transaction . Anchors.getP
