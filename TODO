* BUG: Expanded polymorphic adds conflicts of function type under the
  expression twice causing animid conflicts

* VarAccess should be split for the multiple passes
  * makeExpressionEdit should be passed in a reader
  * OTransaction's Style reader should be separated from the
    cursor reader and transaction layers.
  * OTransaction is Cursor-reader+Transaction
  * Monad for GUI execution (e.g: In BranchGUI):
    StyleReader (OTransaction t m)
  * Monad for Expression generation:
    WriterT VarInfo (OTransaction t m)
    * Which generates:
      StyleReader m (ExpressionGUI m)
  * Avoid name clashes in auto-names

* Inference not inferring enough on:
  foo xs = 0 : xs
  when explicit type of xs is not hole

* Make up type variables implicitly.
  Happens via inference, but as a separate step, so that hole results are unaffected by it.

* Quasi-Monomorphic inference? (Show the monomorphic types a hole
  could be, or that it must be a polymorphic type)

* Type errors still allowed:
  * When changing the exported type
  * When adding/deleting parameters
  * With space/call-with-arg
  * Need to:
    * Allow delete when type-checks in some cases
    * Other manipulations?
* BUG: When using '[' or ']' to add applies, it can type-filter out the
  result we're on and lose the cursor

* For inferred holes the results should also have the unfilled holes as an option?

* When anything is selected, show all the stuff that refer/define that
  same symbol

* When hole result is selected, show (with some different
  visualization) the inferred types and values due to the hole result
  are shown

* Layout

* Bug: <Del> on branch name does not work
  * Cursor does not move, so GUI is not regenerated, apparently. Need
    to rewrite main loop.

* Cleanups:
  * Instead of (VarAccess.NameSource, String) and Guid of name
    seperately, generate a Property for the name of that type? or give
    a setter instead of Guid
  * Rename Data* to Expression*.

* Type synonyms/expansions

* Whenever prejumps is added/popped, we actually update in-version
  data, so it actually creates a new, undo-able version. Need to have
  the JumpBack stack actually be outside the version and in the DB to
  fix this and to make navigation (potentially) nicer when switching
  branches.

  * Jump back should be outside the source control. For this we need
    transactions inside the source control to be able to result in
    extra data outwards, beside the widget's event result.

* Lambda actions not bound to eventmap by Sugar.Func

* Associated comment for any expression to title it? Otherwise we're
  modifying the model to add a comment

* Add JumpTo which gives a hole-like search -- that can sit in a "tab" in place of a DefinitionEdit

* GUI:
  * Projected moves:
    * Has old focal rect
    * May have "projected focal rect"
    * Gets a new "focal rect"
    * Can generate a "projected focal rect" at the projected position of the direction of the movement
      * This "projected focal rect" is to be used by same grid or any parent grid in future movements
      * This "projected focal rect" is sort of a global thing all grids write to?
      * Each grid can add a "delete my projected focal rect" thing before any child action

* Nice to haves:
  * Holes can have same IDs for same results emphasizing sameness
  * LHS needs to be in infix form too
