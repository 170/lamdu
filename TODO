* When applying operator, avoid recreating argument expression

* Dependent lambdas/pis get "t" prefix in name

* TEST: Missing a test to verify that recursive references have a recursive
  type rather than the type "in db"

* Holes not entered in navigation, left with ESC or otherwise pick their
  result?
  * Could be annoying if you wanna go somewhere to check something and you have
    to remmember to <ESC> first!

* Infix:
  * Need to support callWithArg/etc on applyInfix too
  * (_ x) and you press <op>, convert to: (x *_<op>)
  * (x::Int)=>
    1. _ :: Bool              x
    2. _<x> ==> _ x :: Bool   %
    3. _ (x *_<%> _) :: Bool  5
    3. _ (x % *_<5>) :: Bool  right
    4. _ (x % 5 *) :: Bool    =
    5. (x % 5) *_<=> _ :: Bool
       _ *_<=>_ (x % 5) :: Bool

* When hole is "[", press of operator/alpha key makes [*_<key>]

* Green holes for (a|_->a|_) type? Or do we type-check if func is removable?

* Ops.addListItem should be giveAsArgTo which should take the expr to
  write in the function side

* TYPE SYSTEM: Type synonyms/expansions

* When a GetVariable or var name is selected, show all the stuff that
  refer/define that same symbol

* Quasi-Monomorphic inference? (Show the monomorphic types a hole
  could be, or that it must be a polymorphic type)

* Type errors still allowed:
  * When changing the exported type
  * When adding/deleting parameters
  * With space/call-with-arg
  * Need to:
    * Allow delete when type-checks in some cases
    * Other manipulations?
* BUG: When using '[' or ']' to add applies, it can type-filter out the
  result we're on and lose the cursor

* Execution:

fac x = if (x == 0) 1 (rec (x - 1))
    3       3               3
           --------        -------
            False             2
                      -------------
                            6
        ----------------------------
                     6
where
  rec y = x * fac y
                  5
      -   -   -----
      5   3    120

* Whenever prejumps is added/popped, we actually update in-version
  data, so it actually creates a new, undo-able version. Need to have
  the JumpBack stack actually be outside the version and in the DB to
  fix this and to make navigation (potentially) nicer when switching
  branches.

  * Jump back should be outside the source control. For this we need
    transactions inside the source control to be able to result in
    extra data outwards, beside the widget's event result.

* Record params

* Layout

* Lambda actions not bound to eventmap by Sugar.Func

* Associated comment for any expression to title it? Otherwise we're
  modifying the model to add a comment

* Add JumpTo which gives a hole-like search -- that can sit in a "tab" in place of a DefinitionEdit

* GUI:
  * Projected moves:
    * Has old focal rect
    * May have "projected focal rect"
    * Gets a new "focal rect"
    * Can generate a "projected focal rect" at the projected position of the direction of the movement
      * This "projected focal rect" is to be used by same grid or any parent grid in future movements
      * This "projected focal rect" is sort of a global thing all grids write to?
      * Each grid can add a "delete my projected focal rect" thing before any child action

* Nice to haves:
  * Holes can have same IDs for same results emphasizing sameness
  * LHS needs to be in infix form too
  * To improve on DB laziness, maybe we could use  unsafePerformIO on
    transactions such that at the "commit" of the transaction we force
    any non-GC'd thunk-reads if remaining. Read-DB thunks that were
    GC'd will not cost a read. This will mean that e.g: Generating the
    child widget to check if it takes focus will not cost much
    unnecessary work.
  * Import Control.Lens.Tuple unqualified. edwardk says unlikely to
    change, for _1, _2, etc
