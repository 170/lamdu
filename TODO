* UIT is not a good idea (for size):
  * Everything will have to take UIT (Widget ...)
  * so might as well put a (Maybe Cursor->) along the (Size->)

* Can remove the sdwd/frame cache from mainLoop if it is done outside

  * What I have: Widget IO = Size -> (pure stuff with some nested IO actions)

  * What I need: Size -> IO (pure stuff...)

  * Widget cannot do any actions after getting size, but this is
    wrong... What if a scroller gets size and then decides what it
    needs to actually display?

  * Possible solution: Have (Size->) as an extra parameter for some
    widgets, just like (Cursor->) should be --

    * Using a reader monad transformer for (Size->) and (Cursor->)

* Step A: Use a UIT monad transformer for the cursor
* Step B: Move (Size->) to the UIT too

* sdwd should be cached.. How?
  * FlyNav wrapper could be:
    IO Widget -> IO Widget

    and then it could cache the inner sdwd until any inner action
    happens and then it can regenerate the inner sdwd

* Unselectable inferred types(?):
  * Sugar: Replace Maybe wrapper of various actions with a single Maybe
    around the whole actions indicating entity isn't stored
  * In the CodeEdit, make it unselectable when there's no Actions

* Oops! Performance problem in FlyNav!! Generating the SDWD lots and
  lots of times, and then entering lots of times... Probably could be
  OK if we had cached the size... Maybe flyNav should simply be on the
  cached sdwd rather than on the Widget?

* Whenever prejumps is added/popped, we actually update in-version
  data, so it actually creates a new, undo-able version. Need to have
  the JumpBack stack actually be outside the version and in the DB to
  fix this and to make navigation (potentially) nicer when switching
  branches.

* Projected moves:
  * Has old focal rect
  * May have "projected focal rect"
  * Gets a new "focal rect"
  * Can generate a "projected focal rect" at the projected position of the direction of the movement
    * This "projected focal rect" is to be used by same grid or any parent grid in future movements
    * This "projected focal rect" is sort of a global thing all grids write to?
    * Each grid can add a "delete my projected focal rect" thing before any child action

* Free-nav mode?
* "Enter: insert newline" is wrong (e.g: in LiteralInt edit)

* Jump back should be outside the source control. For this we need
  transactions inside the source control to be able to result in
  extra data outwards, beside the widget's event result.

* Oops, if type of left-hand-side is hole, then read-only holes at
   right should NOT have their scope based on their location (They are
   copies!)

   * In fact, maybe type annotations in general should not have all
   the surrounding values in scope? Is that too much free dependency?

   * Maybe read-only hole should not show results at all?

* ParamEdit needs to take the eventmap/actions of ExpressionEdit and
  also add them to the param via the FuncParam actions

* Widget framework:
  * Move "Cursor->" reader into widget

* Add JumpTo which gives a hole-like search -- that can sit in a "tab" in place of a DefinitionEdit

-------

* 1-use wheres to Sugar as "Titled Expressions"

* Associated comment for any expression to title it? Otherwise we're
  modifying the model to add a comment

* Dapaot:
  * Add anim-id-remappings to sugar changes
  * Multi-ids

-------

* ScrollBar

* Lambda unwrap invalidates params

* Need replace/del to mark entire expression hierarchy now unreachable
  as invalidated for delete/modify conflicts
