{-# LANGUAGE KindSignatures, TemplateHaskell, DeriveFunctor, DeriveFoldable, DeriveTraversable, GeneralizedNewtypeDeriving, DeriveDataTypeable #-}
module Lamdu.CodeEdit.Sugar.Types
  ( Definition(..), drName, drGuid, drType, drBody
  , DefinitionBody(..)
  , ListItemActions(..), itemAddNext, itemDelete
  , FuncParamActions(..), fpListItemActions, fpGetExample
  , DefinitionExpression(..), deContent, deIsTypeRedundant, deMNewType
  , DefinitionContent(..)
  , DefinitionNewType(..)
  , DefinitionBuiltin(..)
  , Actions(..)
    , giveAsArg, callWithArg, callWithNextArg
    , setToHole, replaceWithNewHole, cut, giveAsArgToOperator
  , Body(..)
    , _BodyLam, _BodyApply, _BodyGetVar, _BodyHole
    , _BodyInferred, _BodyCollapsed, _BodyLiteralInteger
    , _BodyAtom, _BodyList, _BodyRecord, _BodyTag
  , Payload(..), plInferredTypes, plActions, plNextHole
  , ExpressionP(..)
    , rGuid, rBody, rPayload, rHiddenGuids, rPresugaredExpression
  , NameSource(..), NameCollision(..), Name(..), MStoredName
  , DefinitionN, DefinitionU
  , Expression, ExpressionN, ExpressionU
  , BodyN, BodyU
  , WhereItem(..)
  , ListItem(..), ListActions(..), List(..)
  , RecordField(..), rfMItemActions, rfTag, rfExpr
  , Kind(..)
  , Record(..), rKind, rFields
  , FieldList(..), flItems, flMAddFirstItem
  , GetField(..), gfRecord, gfTag
  , GetVarType(..)
  , GetVar(..), gvIdentifier, gvName, gvJumpTo, gvVarType
  , GetParams(..), gpDefGuid, gpDefName, gpJumpTo
  , SpecialArgs(..), _NoSpecialArgs, _ObjectArg, _InfixArgs
  , Apply(..), aFunc, aSpecialArgs, aAnnotatedArgs
  , Lam(..), lKind, lParam, lIsDep, lResultType
  , FuncParamType(..)
  , FuncParam(..), fpName, fpGuid, fpId, fpAltIds, fpVarKind, fpHiddenLambdaGuid, fpType, fpMActions
  , TagG(..), tagName, tagGuid
  , Hole(..), holeMActions
  , HoleResultSeed(..), _ResultSeedExpression, _ResultSeedNewTag, _ResultSeedNewDefinition
  , ScopeItem
  , Scope(..), scopeLocals, scopeGlobals, scopeTags, scopeGetParams
  , HoleActions(..), holeScope, holePaste, holeMDelete, holeResult, holeInferExprType, holeInferredType
  , StorePoint(..)
  , HoleResult(..)
    , holeResultInferred
    , holeResultConverted
    , holeResultPick, holeResultPickPrefix
  , LiteralInteger(..)
  , Inferred(..), iValue, iMAccept, iHole
  , Collapsed(..), cFuncGuid, cCompact, cFullExpression, cFullExprHasInfo
  , T, CT
  , PrefixAction, emptyPrefixAction
  , ExprStorePoint
  ) where

import Control.Monad.Trans.State (StateT)
import Data.Binary (Binary)
import Data.Cache (Cache)
import Data.Derive.Monoid (makeMonoid)
import Data.DeriveTH (derive)
import Data.Foldable (Foldable)
import Data.Monoid (Monoid(..))
import Data.Store.Guid (Guid)
import Data.Store.IRef (Tag)
import Data.Store.Transaction (Transaction)
import Data.Traversable (Traversable)
import Data.Typeable (Typeable)
import Lamdu.Data.Expression (Kind(..))
import Lamdu.Data.Expression.IRef (DefI)
import qualified Control.Lens.TH as Lens
import qualified Data.List as List
import qualified Lamdu.Data.Definition as Definition
import qualified Lamdu.Data.Expression.IRef as ExprIRef
import qualified Lamdu.Data.Expression.Infer as Infer

type T = Transaction
type CT m = StateT Cache (T m)

type PrefixAction m = T m ()

emptyPrefixAction :: Monad m => PrefixAction m
emptyPrefixAction = return ()

data Actions m = Actions
  { _giveAsArg :: PrefixAction m -> T m Guid
  -- Turn "x" to "x ? _" where "?" is an operator-hole.
  -- Given string is initial hole search term.
  , _giveAsArgToOperator :: T m Guid
  , _callWithNextArg :: PrefixAction m -> CT m (Maybe (T m Guid))
  , _callWithArg :: PrefixAction m -> CT m (Maybe (T m Guid))
  , _setToHole :: T m Guid
  , _replaceWithNewHole :: T m Guid
  , _cut :: T m Guid
  }

data Payload name m = Payload
  { _plInferredTypes :: [Expression name m]
  , _plActions :: Maybe (Actions m)
  , _plNextHole :: Maybe (Expression name m)
  }

newtype StorePoint t = StorePoint { unStorePoint :: ExprIRef.ExpressionI t }
  deriving (Eq, Binary, Typeable)

type ExprStorePoint m = ExprIRef.ExpressionM m (Maybe (StorePoint (Tag m)))

data ExpressionP name m pl = Expression
  { _rGuid :: Guid
  , _rBody :: Body name m (ExpressionP name m pl)
  , _rPayload :: pl
  , -- Guids from data model expression which were sugared out into
    -- this sugar expression.
    -- If the cursor was on them for whatever reason, it should be
    -- mapped into the sugar expression's guid.
    _rHiddenGuids :: [Guid]
  , _rPresugaredExpression :: ExprStorePoint m
  } deriving (Functor, Foldable, Traversable)

data NameSource = AutoGeneratedName | StoredName
  deriving (Show)
data NameCollision = NoCollision | Collision {-Disambiguator:-} Int
  deriving (Show)
data Name = Name
  { nNameSource :: NameSource
  , nNameCollisionSuffix :: NameCollision
  , nName :: String
  } deriving (Show)
type MStoredName = Maybe String

type Expression name m = ExpressionP name m (Payload name m)
type ExpressionN m = Expression Name m
type ExpressionU m = Expression MStoredName m

type BodyN m = Body Name m (ExpressionN m)
type BodyU m = Body MStoredName m (ExpressionU m)

data ListItemActions m = ListItemActions
  { _itemAddNext :: T m Guid
  , _itemDelete :: T m Guid
  }

data FuncParamActions name m = FuncParamActions
  { _fpListItemActions :: ListItemActions m
  , _fpGetExample :: CT m (Expression name m)
  }

data FuncParamType = FuncParameter | FuncFieldParameter

-- TODO:
-- FuncParam for lambda needs GetExample, but not ListItemActions
-- FuncParam for pi needs neither
-- FuncParam for definition needs both
-- So separate the types properly
data FuncParam name m expr = FuncParam
  { -- non-unique (e.g: tag guid). Name attached here:
    _fpGuid :: Guid
  , _fpId :: Guid
  , _fpAltIds :: [Guid]
  , _fpVarKind :: FuncParamType
  , _fpName :: name
  , _fpHiddenLambdaGuid :: Maybe Guid
  , _fpType :: expr
  , _fpMActions :: Maybe (FuncParamActions name m)
  } deriving (Functor, Foldable, Traversable)

data Lam name m expr = Lam
  { _lKind :: Kind
  , _lParam :: FuncParam name m expr
  , _lIsDep :: Bool
  , _lResultType :: expr
  } deriving (Functor, Foldable, Traversable)

data HoleResult name m = HoleResult
  { _holeResultInferred :: ExprIRef.ExpressionM m (Infer.Inferred (DefI (Tag m)))
  , _holeResultConverted :: Expression name m
  , _holeResultPick :: T m (Maybe Guid)
  , _holeResultPickPrefix :: PrefixAction m
  }

data HoleResultSeed m
  = ResultSeedExpression (ExprStorePoint m)
  | ResultSeedNewTag String
  | ResultSeedNewDefinition String

type ScopeItem m a = (a, ExprIRef.ExpressionM m ())

data Scope name m = Scope
  { _scopeLocals    :: [ScopeItem m (GetVar name m)]
  , _scopeGlobals   :: [ScopeItem m (GetVar name m)]
  , _scopeTags      :: [ScopeItem m (TagG name)]
  , _scopeGetParams :: [ScopeItem m (GetParams name m)]
  }

data HoleActions name m = HoleActions
  { _holeScope :: T m (Scope name m)
  , -- Infer expression "on the side" (not in the hole position),
    -- but with the hole's scope.
    -- If given expression does not type check on its own, returns Nothing.
    -- (used by HoleEdit to suggest variations based on type)
    _holeInferExprType :: ExprIRef.ExpressionM m () -> CT m (Maybe (ExprIRef.ExpressionM m ()))
  , _holeInferredType :: ExprIRef.ExpressionM m ()
  , _holeResult :: HoleResultSeed m -> CT m (Maybe (HoleResult name m))
  , _holePaste :: Maybe (T m Guid)
  , -- TODO: holeMDelete is always Nothing, not implemented yet
    _holeMDelete :: Maybe (T m Guid)
  }

newtype Hole name m = Hole
  { _holeMActions :: Maybe (HoleActions name m)
  }

data LiteralInteger m = LiteralInteger
  { liValue :: Integer
  , liSetValue :: Maybe (Integer -> T m ())
  }

data Inferred name m expr = Inferred
  { _iValue :: expr
  , _iMAccept :: Maybe (T m Guid)
  , _iHole :: Hole name m
  } deriving (Functor, Foldable, Traversable)

-- TODO: New name. This is not only for polymorphic but also for eta-reduces etc
data Collapsed name m expr = Collapsed
  { _cFuncGuid :: Guid
  , _cCompact :: GetVar name m
  , _cFullExpression :: expr
  , _cFullExprHasInfo :: Bool
  } deriving (Functor, Foldable, Traversable)

-- TODO: Do we want to store/allow-access to the implicit type params (nil's type, each cons type?)
data ListItem m expr = ListItem
  { liMActions :: Maybe (ListItemActions m)
  , liExpr :: expr
  } deriving (Functor, Foldable, Traversable)

data ListActions m = ListActions
  { addFirstItem :: T m Guid
  , replaceNil :: T m Guid
  }

data List m expr = List
  { lValues :: [ListItem m expr]
  , lMActions :: Maybe (ListActions m)
  } deriving (Functor, Foldable, Traversable)

data RecordField m expr = RecordField
  { _rfMItemActions :: Maybe (ListItemActions m)
  , _rfTag :: expr
  , _rfExpr :: expr -- field type or val
  } deriving (Functor, Foldable, Traversable)

data FieldList m expr = FieldList
  { _flItems :: [RecordField m expr]
  , _flMAddFirstItem :: Maybe (T m Guid)
  } deriving (Functor, Foldable, Traversable)

data Record m expr = Record
  { _rKind :: Kind -- record type or val
  , _rFields :: FieldList m expr
  } deriving (Functor, Foldable, Traversable)

data GetField expr = GetField
  { _gfRecord :: expr
  , _gfTag :: expr
  } deriving (Functor, Foldable, Traversable)

data GetVarType = GetDefinition | GetFieldParameter | GetParameter
  deriving (Eq, Ord)

data GetVar name m = GetVar
  { _gvIdentifier :: Guid
  , _gvName :: name
  , _gvJumpTo :: T m Guid
  , _gvVarType :: GetVarType
  }

data GetParams name m = GetParams
  { _gpDefGuid :: Guid
  , _gpDefName :: name
  , _gpJumpTo :: T m Guid
  }

data TagG name = TagG
  { _tagGuid :: Guid
  , _tagName :: name
  } deriving (Functor, Foldable, Traversable)

data SpecialArgs expr
  = NoSpecialArgs
  | ObjectArg expr
  | InfixArgs expr expr
  deriving (Functor, Foldable, Traversable)

data Apply name expr = Apply
  { _aFunc :: expr
  , _aSpecialArgs :: SpecialArgs expr
  , _aAnnotatedArgs :: [(TagG name, expr)]
  } deriving (Functor, Foldable, Traversable)

data Body name m expr
  = BodyLam (Lam name m expr)
  | BodyApply (Apply name expr)
  | BodyHole (Hole name m)
  | BodyInferred (Inferred name m expr)
  | BodyCollapsed (Collapsed name m expr)
  | BodyLiteralInteger (LiteralInteger m)
  | BodyAtom String
  | BodyList (List m expr)
  | BodyRecord (Record m expr)
  | BodyGetField (GetField expr)
  | BodyTag (TagG name)
  | BodyGetVar (GetVar name m)
  | BodyGetParams (GetParams name m)
  deriving (Functor, Foldable, Traversable)

instance Show expr => Show (FuncParam name m expr) where
  show fp =
    concat ["(", show (_fpGuid fp), ":", show (_fpType fp), ")"]

instance Show expr => Show (Body name m expr) where
  show (BodyLam (Lam Val _paramType _isDep _body)) = "TODO:Lam"
  show (BodyLam (Lam Type paramType isDep resultType)) =
    paramName ++ show paramType ++ " -> " ++ show resultType
    where
      paramName | isDep = "_:"
                | otherwise = ""
  show BodyHole {} = "Hole"
  show BodyInferred {} = "Inferred"
  show BodyCollapsed {} = "Collapsed"
  show (BodyLiteralInteger (LiteralInteger i _)) = show i
  show (BodyAtom atom) = atom
  show (BodyList (List items _)) =
    concat
    [ "["
    , List.intercalate ", " $ map (show . liExpr) items
    , "]"
    ]
  show BodyApply {} = "LabelledApply:TODO"
  show BodyRecord {} = "Record:TODO"
  show BodyGetField {} = "GetField:TODO"
  show BodyTag {} = "Tag:TODO"
  show BodyGetVar {} = "GetVar:TODO"
  show BodyGetParams {} = "GetParams:TODO"

data DefinitionNewType name m expr = DefinitionNewType
  { dntNewType :: expr
  , dntAcceptNewType :: T m ()
  } deriving (Functor, Foldable, Traversable)

data WhereItem name m expr = WhereItem
  { wiValue :: DefinitionContent name m expr
  , wiGuid :: Guid
  , wiName :: name
  , wiHiddenGuids :: [Guid]
  , wiActions :: Maybe (ListItemActions m)
  } deriving (Functor, Foldable, Traversable)

-- Common data for definitions and where-items
data DefinitionContent name m expr = DefinitionContent
  { dDepParams :: [FuncParam name m expr]
  , dParams :: [FuncParam name m expr]
  , dBody :: expr
  , dWhereItems :: [WhereItem name m expr]
  , dAddFirstParam :: T m Guid
  , dAddInnermostWhereItem :: T m Guid
  } deriving (Functor, Foldable, Traversable)

data DefinitionExpression name m expr = DefinitionExpression
  { _deContent :: DefinitionContent name m expr
  , _deIsTypeRedundant :: Bool
  , _deMNewType :: Maybe (DefinitionNewType name m expr)
  } deriving (Functor, Foldable, Traversable)

data DefinitionBuiltin m = DefinitionBuiltin
  { biName :: Definition.FFIName
  -- Consider removing Maybe'ness here
  , biMSetName :: Maybe (Definition.FFIName -> T m ())
  }

data DefinitionBody name m expr
  = DefinitionBodyExpression (DefinitionExpression name m expr)
  | DefinitionBodyBuiltin (DefinitionBuiltin m)
  deriving (Functor, Foldable, Traversable)

data Definition name m expr = Definition
  { _drGuid :: Guid
  , _drName :: name
  , _drType :: expr
  , _drBody :: DefinitionBody name m expr
  } deriving (Functor, Foldable, Traversable)

type DefinitionN m = Definition Name m (Expression Name m)
type DefinitionU m = Definition MStoredName m (Expression MStoredName m)

derive makeMonoid ''Scope
Lens.makePrisms ''Body
Lens.makePrisms ''SpecialArgs
Lens.makePrisms ''HoleResultSeed
Lens.makeLenses ''Actions
Lens.makeLenses ''Definition
Lens.makeLenses ''DefinitionExpression
Lens.makeLenses ''Inferred
Lens.makeLenses ''Collapsed
Lens.makeLenses ''Lam
Lens.makeLenses ''FuncParam
Lens.makeLenses ''RecordField
Lens.makeLenses ''FieldList
Lens.makeLenses ''Record
Lens.makeLenses ''GetVar
Lens.makeLenses ''GetParams
Lens.makeLenses ''Apply
Lens.makeLenses ''GetField
Lens.makeLenses ''TagG
Lens.makeLenses ''Body
Lens.makeLenses ''ListItemActions
Lens.makeLenses ''FuncParamActions
Lens.makeLenses ''Payload
Lens.makeLenses ''ExpressionP
Lens.makeLenses ''HoleResult
Lens.makeLenses ''Scope
Lens.makeLenses ''HoleActions
Lens.makeLenses ''Hole
